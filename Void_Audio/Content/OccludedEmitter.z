/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Class: OccludedEmitter                                                                                   */
/* Brief: An implementation of an occluded emitter.                                                         */
/*                                                                                                          */
/* Author: Andrea Ellinger                                                                                  */
/************************************************************************************************************/

enum OcclusionQuality { SingleCast, Low, Medium, High }

class OccludedEmitter : ZilchComponent
{
  [Dependency]
  var Emitter : SoundEmitter;
  
  [Dependency]
  var Transform : Transform;
  
  // Note: if the cone is too large it can think there's an area with no occlusion even though
  // there's actually no path for the sound to get to the listener
  [Property]
  var ConeSizeRadians : Real = Math.Pi / 50.0;
  
  [Property]
  var MaxDistance : Real = 50.0;
  
  [Property]
  var Quality : OcclusionQuality = OcclusionQuality.Low;
  
  var ListenerObject : Cog;
  var LowPass : LowPassNode = Audio.LowPassNode();
  var Volume : VolumeNode = Audio.VolumeNode();
  var AngleValues : Array[Real2] = Array[Real2]();
  var ReducedVolume : Real;
  var LowPassCutoff : Real;
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    
    this.ListenerObject = this.Space.FindObjectByName("Player");
    
    this.LowPass.CutoffFrequency = 20000.0;
    this.Volume.Volume = 1.0;
    this.Emitter.OutputNode.InsertNodeAfter(this.LowPass);
    this.Emitter.OutputNode.InsertNodeAfter(this.Volume);
    
    var howManyCasts = 0;
    var angleIncrement = 0.0;
    var angle = this.ConeSizeRadians;
    
    if (this.Quality == OcclusionQuality.Low)
    {
      howManyCasts = 4;
      angleIncrement = Math.Pi * 2.0 / 4.0;
    }
    else if (this.Quality == OcclusionQuality.Medium)
    {
      howManyCasts = 8;
      angleIncrement = Math.Pi * 2.0 / 8.0;
    }
    else if (this.Quality == OcclusionQuality.High)
    {
      howManyCasts = 14;
      angleIncrement = Math.Pi * 2.0 / 8.0;
    }
    
    this.AngleValues.Push(Real2(0.0, 0.0));
    
    for (var i = 0; i < howManyCasts; ++i)
    {
      if (i == 8)
      {
        angle /= 2.0;
        angleIncrement = Math.Pi * 2.0 / 6.0;
      }
      
      this.AngleValues.Push(Real2(angle, i * angleIncrement));
    }
  }

  function OnLogicUpdate(event : UpdateEvent)
  {
    var percent = this.GetOcclusionPercent();
    
    this.LowPass.CutoffFrequency = 20000.0 - ((20000.0 - this.LowPassCutoff) * percent);
    this.Volume.Volume = 1.0 - ((1.0 - this.ReducedVolume) * percent);
  }
  
  function GetOcclusionPercent() : Real
  {
    var vectorToListener = this.ListenerObject.Transform.WorldTranslation - this.Transform.WorldTranslation;
    
    if (Math.LengthSq(vectorToListener) > this.MaxDistance * this.MaxDistance)
      return 0;
    
    var rotationVector1 = Math.Normalize(Real3(-vectorToListener.Y, vectorToListener.X, 0));
    var rotationVector2 = Math.Normalize(vectorToListener);
    var hitCount = 0;
    var castsWithHits = 0;
    this.LowPassCutoff = 0;
    this.ReducedVolume = 0;
    
    for (var i = 0; i < this.AngleValues.Count; ++i)
    {
      var foundSomething = false;
      
      var firstRotation = Math.RotateVector(vectorToListener, rotationVector1, this.AngleValues[i].X);
      var secondRotation = Math.RotateVector(firstRotation, rotationVector2, this.AngleValues[i].Y);
      var endPoint = this.Transform.WorldTranslation + secondRotation;
      
      this.DrawLine(endPoint);
      
      var results = this.Space.PhysicsSpace.CastSegmentResults(this.Transform.WorldTranslation, endPoint, 20);
      
      foreach (var hit in results)
      {
        if (hit.ObjectHit.OcclusionObject != null)
        {
          ++hitCount;
          foundSomething = true;
          this.LowPassCutoff += hit.ObjectHit.OcclusionObject.LowPassCutoff;
          this.ReducedVolume += hit.ObjectHit.OcclusionObject.OccludedVolume;
        }
      }
      
      if (foundSomething == true)
        ++castsWithHits;
    }
    
    if (hitCount > 0)
    {
      this.LowPassCutoff /= hitCount;
      this.ReducedVolume /= hitCount;
    }
    
    return castsWithHits as Real / this.AngleValues.Count;
  }
  
  function DrawLine(endPoint : Real3)
  {
    var line = DebugLine();
    line.Start = this.Transform.WorldTranslation;
    line.End = endPoint;
    line.Color = Real4(1.0,1.0,1.0,1.0);
    DebugDraw.Add(line);
  }
}
