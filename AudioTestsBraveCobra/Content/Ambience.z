// This script will play random ambience using a looping background cue and three
// ambience cues which will be placed at random positions within a specified radius.
// Wind is created with generated white noise, a low pass filter, and panning.
class Ambience : ZilchComponent
{
  // The position of ambience cues is based on this object's position
  [Dependency] var Transform : Transform;
  
  // The high volume for the generated wind, when the low pass filter is at its highest cutoff frequency
  [Property] var WindVolumeDay : Real = 0.6;
  [Property] var WindVolumeNight : Real = 0.6;
  // The minimum value for the randomized time when the wind goes from low volume to high volume
  [Property] var WindAttackMin : Real = 3.0;
  // The maximum value (in seconds) for the randomized time when the wind goes from low volume to high volume
  [Property] var WindAttackMax : Real = 10.0;
  // The minimum value (in seconds) for the randomized time when the wind goes from high volume to low volume
  [Property] var WindReleaseMin : Real = 3.0;
  // The maximum value (in seconds) for the randomized time when the wind goes from high volume to low volume
  [Property] var WindReleaseMax : Real = 10.0;
  // The minimum value (in seconds) for the randomized time used to pan the wind from left to right and vice versa
  [Property] var WindPanMinTime : Real = 2.0;
  // The maximum value (in seconds) for the randomized time used to pan the wind from left to right and vice versa
  [Property] var WindPanMaxTime: Real = 8.0;
  // The minimum value for the randomized panning volume used for the quiet side (other side will be 1.0)
  [Property] var WindPannedMin : Real = 0.2;
  // The maximum value for the randomized panning volume used for the quiet side (other side will be 1.0)
  [Property] var WindPannedMax : Real = 0.7;
  // A looping background cue which will be constantly playing
  [Property] var BackgroundDay : SoundCue;
  [Property] var BackgroundNight : SoundCue;
  // The first ambience cue
  [Property] var AmbienceCue1Day : SoundCue;
  [Property] var AmbienceCue1Night : SoundCue;
  // The minimum radius for the randomized position (the sound will never be closer to this object than this value)
  [Property] var Cue1MinRadius : Real = 5.0;
  // The maximum radius for the randomized position (the sound will never be farther from this object than this value)
  [Property] var Cue1MaxRadius : Real = 20.0;
  // The minimum value for the randomized time (in seconds) that will pass before this cue is played again
  [Property] var Cue1MinWait : Real = 3.0;
  // The maximum value (in seconds) for the randomized time that will pass before this cue is played again
  [Property] var Cue1MaxWait : Real = 10.0;
  // The second ambience cue
  [Property] var AmbienceCue2Day : SoundCue;
  [Property] var AmbienceCue2Night : SoundCue;
  // The minimum radius for the randomized position (the sound will never be closer to this object than this value)
  [Property] var Cue2MinRadius : Real = 5.0;
  // The maximum radius for the randomized position (the sound will never be farther from this object than this value)
  [Property] var Cue2MaxRadius : Real = 20.0;
  // The minimum value for the randomized time (in seconds) that will pass before this cue is played again
  [Property] var Cue2MinWait : Real = 3.0;
  // The maximum value (in seconds) for the randomized time that will pass before this cue is played again
  [Property] var Cue2MaxWait : Real = 10.0;
  // The third ambience cue
  [Property] var AmbienceCue3Day : SoundCue;
  [Property] var AmbienceCue3Night : SoundCue;
  // The minimum radius for the randomized position (the sound will never be closer to this object than this value)
  [Property] var Cue3MinRadius : Real = 5.0;
  // The maximum radius for the randomized position (the sound will never be farther from this object than this value)
  [Property] var Cue3MaxRadius : Real = 20.0;
  // The minimum value for the randomized time (in seconds) that will pass before this cue is played again
  [Property] var Cue3MinWait : Real = 3.0;
  // The maximum value (in seconds) for the randomized time that will pass before this cue is played again
  [Property] var Cue3MaxWait : Real = 10.0;
  
  // The SoundNode used to generate white noise
  var Noise : GeneratedWaveNode = Audio.GeneratedWaveNode();
  // The SoundNode used to control the wind's volume
  var Volume : VolumeNode = Audio.VolumeNode();
  // The low pass filter used to create the wind
  var LowPass : LowPassNode = Audio.LowPassNode();
  // The panning filter used to move the wind from side to side
  var Panning : PanningNode = Audio.PanningNode();
  // The increment used to change the low pass filter's cutoff frequency (start at less than 0 because starting from low point)
  var Increment : Real = -50.0;
  // The object used to get random values
  var RandomNumbers : Random = Random();
  // An object with a SoundEmitter for the first ambience cue
  var Emitter1 : Cog;
  // An object with a SoundEmitter for the second ambience cue
  var Emitter2 : Cog;
  // An object with a SoundEmitter for the third ambience cue
  var Emitter3 : Cog;
  // The last angle used for the first ambience cue's position
  var Cue1LastAngle : Real = 0.0;
  // The last angle used for the second ambience cue's position
  var Cue2LastAngle : Real = 0.0;
  // The last angle used for the third ambience cue's position
  var Cue3LastAngle : Real = 0.0;
  // The low volume for the generated wind, when the low pass filter is at its lowest cutoff frequency
  var WindLowVolume : Real = 0.2;
  // The minimum value (in Hz) for the randomized cutoff frequncy when the wind is at its loudest point
  var WindHighCutoffMin : Real = 1500.0;
  // The maximum value (in Hz) for the randomized cutoff frequncy when the wind is at its loudest point
  var WindHighCutoffMax : Real = 2000.0;
  // The minimum value (in Hz) for the randomized cutoff frequncy when the wind is at its quietest point
  var WindLowCutoffMin : Real = 100.0;
  // The maximum value (in Hz) for the randomized cutoff frequncy when the wind is at its quietest point
  var WindLowCutoffMax : Real = 1000.0;
  // Whether to play the day or night SoundCues
  var Day : Boolean = true;
  // The SoundInstance created when playing the background SoundCue
  var BackgroundInstance : SoundInstance;
  
  function Initialize(init : CogInitializer)
  {
    // Connect the LogicUpdate function
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    // Connect to the event to switch from day to night and vice versa
    Zero.Connect(this.Space, Events.DayCycleEvent, this.SetDay);
    
    // Start playing the looping background cue
    this.BackgroundInstance = this.Space.SoundSpace.PlayCue(this.BackgroundDay);
    // Set the values on the generated noise SoundNode
    this.Noise.WaveType = SynthWaveType.Noise;
    this.Noise.Volume = 0.2;
    // Start playing the white noise
    this.Noise.Play();
    // Set the cutoff frequency on the low pass filter
    this.LowPass.CutoffFrequency = this.WindLowCutoffMin;
    // Attach the white noise to the low pass node
    this.LowPass.AddInputNode(this.Noise);
    // Set the volume on the VolumeNode
    this.Volume.Volume = this.WindLowVolume;
    // Attach the low pass node to the volume node
    this.Volume.AddInputNode(this.LowPass);
    // Set the volume on the panning node
    this.Panning.LeftVolume = this.WindPannedMax;
    // Attach the volume node to the panning node
    this.Panning.AddInputNode(this.Volume);
    // Attach the panning node to the SoundSpace output node
    this.Space.SoundSpace.SoundNode.AddInputNode(this.Panning);
    // Create the first emitter object
    this.Emitter1 = this.Space.Create(Archetype.BasicSoundEmitter);
    // Create the second emitter object
    this.Emitter2 = this.Space.Create(Archetype.BasicSoundEmitter);
    // Create the third emitter object
    this.Emitter3 = this.Space.Create(Archetype.BasicSoundEmitter);
    
    // Start panning the wind
    this.ChangePanning();
    // Start interpolating the volume and low pass for the wind
    this.ChangeWind();
    // Delay the first ambience cue
    var sequence = Actions.Sequence(this.Owner.Actions);
    Actions.Delay(sequence, this.RandomNumbers.Range(this.Cue1MinWait, this.Cue1MaxWait));
    Actions.Call(sequence, this.PlayCue1);
    // Delay the second ambience cue
    var sequence2 = Actions.Sequence(this.Owner.Actions);
    Actions.Delay(sequence2, this.RandomNumbers.Range(this.Cue2MinWait, this.Cue2MaxWait));
    Actions.Call(sequence2, this.PlayCue2);
    // Delay the third ambience cue
    var sequence3 = Actions.Sequence(this.Owner.Actions);
    Actions.Delay(sequence3, this.RandomNumbers.Range(this.Cue3MinWait, this.Cue3MaxWait));
    Actions.Call(sequence3, this.PlayCue3);
  }

  function OnLogicUpdate(event : UpdateEvent)
  {    
    // Change the low pass filter's cutoff frequency every update
    this.LowPass.CutoffFrequency = this.LowPass.CutoffFrequency + this.Increment;
  }
  
  function SetDay(event : DayCycleEvent)
  {
    // If already set to this day value, don't do anything
    if (this.Day == event.Day)
      return;
    
    // Fade out the current background instance
    this.BackgroundInstance.InterpolateVolume(0.0, 3.0);
    // Delay stopping the instance
    var stopSequence = Actions.Sequence(this.Owner.Actions);
    Actions.Delay(stopSequence, 3.0);
    Actions.Call(stopSequence, this.BackgroundInstance.Stop);
      
    // If switching from day to night, play the night background
    if (this.Day == true && event.Day == false)
      this.BackgroundInstance = this.Space.SoundSpace.PlayCuePaused(this.BackgroundNight);
    // Otherwise play the day background
    else
      this.BackgroundInstance = this.Space.SoundSpace.PlayCuePaused(this.BackgroundDay);
      
    // Set the volume to 0
    this.BackgroundInstance.Volume = 0.0;
    // Un-pause the instance
    this.BackgroundInstance.Paused = false;
    // Fade in the background instance
    this.BackgroundInstance.InterpolateVolume(1.0, 3.0);
    
    // Set the variable for which one is playing now
    this.Day = event.Day;
  }
  
  function ChangePanning()
  {
    // Get a random time for this panning interpolation
    var time = this.RandomNumbers.Range(this.WindPanMinTime, this.WindPanMaxTime);
    
    // Are we now panning from left to right?
    if (this.Panning.LeftVolume < this.Panning.RightVolume)
    {
      // Interpolate the left volume back to 1.0 over the time
      this.Panning.InterpolateLeftVolume(1.0, time);
      // Interpolate the right volume to a random value over the time
      this.Panning.InterpolateRightVolume(this.RandomNumbers.Range(this.WindPannedMin, this.WindPannedMax), time);
    }
    // If not, we are panning from right to left
    else
    {
      // Interpolate the right volume back to 1.0 over the time
      this.Panning.InterpolateRightVolume(1.0, time);
      // Interpolate the left volume to a random value over the time
      this.Panning.InterpolateLeftVolume(this.RandomNumbers.Range(this.WindPannedMin, this.WindPannedMax), time);
    }
    
    // Delay the next call of this function by the time
    var sequence = Actions.Sequence(this.Owner.Actions);
    Actions.Delay(sequence, time);
    Actions.Call(sequence, this.ChangePanning);
  }
  
  function ChangeWind()
  {
    // Create variables for the frequency difference and the time
    var frequencyDifference = 1.0;
    var time = 1.0;
    
    // If the increment is negative, we were getting quieter and now need to get louder
    if (this.Increment < 0.0)
    {
      // Get a random time for the interpolation using the attack values
      time = this.RandomNumbers.Range(this.WindAttackMin, this.WindAttackMax);
      // Interpolate the volume to the maximum over half the time
      if (this.Day == true)
        this.Volume.InterpolateVolume(this.WindVolumeDay, time * 0.5);
      else
        this.Volume.InterpolateVolume(this.WindVolumeNight, time * 0.5);
      // Pick a random high cutoff frequency and figure out the difference between that and the current cutoff
      frequencyDifference = this.RandomNumbers.Range(this.WindHighCutoffMin, this.WindHighCutoffMax) - this.LowPass.CutoffFrequency;
    }
    else
    {
      // Get a random time for the interpolation using the release values
      time = this.RandomNumbers.Range(this.WindReleaseMin, this.WindReleaseMax);
      // Interpolate the volume to the minimum over half the time
      this.Volume.InterpolateVolume(this.WindLowVolume, time * 0.5);
      // Pick a random low cutoff frequency and figure out the difference between that and the current cutoff
      frequencyDifference = this.RandomNumbers.Range(this.WindLowCutoffMin, this.WindLowCutoffMax) - this.LowPass.CutoffFrequency;
    }
    
    // Set the amount the cutoff frequency should change on every update
    this.Increment = frequencyDifference / time / 60;
    
    // Delay the next call of this function by the time
    var sequence = Actions.Sequence(this.Owner.Actions);
    Actions.Delay(sequence, time);
    Actions.Call(sequence, this.ChangeWind);
  }
  
  function PlayCue1()
  {
    // Pass in the values to play the first ambience cue
    if (this.Day)
      this.PlayAmbienceCue(1, this.Cue1LastAngle, this.Cue1MinRadius, this.Cue1MaxRadius, this.Emitter1, this.AmbienceCue1Day);
    else
      this.PlayAmbienceCue(1, this.Cue1LastAngle, this.Cue1MinRadius, this.Cue1MaxRadius, this.Emitter1, this.AmbienceCue1Night);
    
    // Delay the next call of this function by a random time
    var sequence = Actions.Sequence(this.Owner.Actions);
    Actions.Delay(sequence, this.RandomNumbers.Range(this.Cue1MinWait, this.Cue1MaxWait));
    Actions.Call(sequence, this.PlayCue1);
  }
  
  function PlayCue2()
  {
    // Pass in the values to play the second ambience cue
    if (this.Day)
      this.PlayAmbienceCue(2, this.Cue2LastAngle, this.Cue2MinRadius, this.Cue2MaxRadius, this.Emitter2, this.AmbienceCue2Day);
    else
      this.PlayAmbienceCue(2, this.Cue2LastAngle, this.Cue2MinRadius, this.Cue2MaxRadius, this.Emitter2, this.AmbienceCue2Night);
    
    // Delay the next call of this function by a random time
    var sequence = Actions.Sequence(this.Owner.Actions);
    Actions.Delay(sequence, this.RandomNumbers.Range(this.Cue2MinWait, this.Cue2MaxWait));
    Actions.Call(sequence, this.PlayCue2);
  }
  
  function PlayCue3()
  {
    // Pass in the values to play the third ambience cue
    if (this.Day)
      this.PlayAmbienceCue(3, this.Cue3LastAngle, this.Cue3MinRadius, this.Cue3MaxRadius, this.Emitter3, this.AmbienceCue3Day);
    else
      this.PlayAmbienceCue(3, this.Cue3LastAngle, this.Cue3MinRadius, this.Cue3MaxRadius, this.Emitter3, this.AmbienceCue3Night);
    
    // Delay the next call of this function by a random time
    var sequence = Actions.Sequence(this.Owner.Actions);
    Actions.Delay(sequence, this.RandomNumbers.Range(this.Cue3MinWait, this.Cue3MaxWait));
    Actions.Call(sequence, this.PlayCue3);
  }
  
  function PlayAmbienceCue(whichCue : Integer, lastAngle : Real, minRadius : Real, maxRadius : Real, emitter : Cog, cue : SoundCue)
  {
    // Pick a random angle between 0 and 2 * pi
    var angle = this.RandomNumbers.Range(0.0, Math.Pi * 2.0);
    // If that angle is too close to the last one, get another one
    while (Math.Abs(angle - lastAngle) < Math.Pi / 6.0)
      angle = this.RandomNumbers.Range(0.0, Math.Pi * 2.0);
      
    // Update the last angle variable
    if (whichCue == 1)
      this.Cue1LastAngle = angle;
    else if (whichCue == 2)
      this.Cue2LastAngle = angle;
    else 
      this.Cue3LastAngle = angle;
      
    // Get a random radius vector within the min and max values
    var radius = Real3(this.RandomNumbers.Range(minRadius, maxRadius), 0.0, 0.0);
    // Rotate the radius vector by the angle and add it to this object's position
    var emitPosition = this.Transform.WorldTranslation + Math.RotateVector(radius, Real3(0.0, 1.0, 0.0), angle);
    // Move the emitter to that position
    emitter.Transform.WorldTranslation = emitPosition;
    // Play the SoundCue
    emitter.SoundEmitter.PlayCue(cue);
  }
}
